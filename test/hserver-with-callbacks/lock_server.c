/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "lock.h"
#include "sha.h"
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include "client.h"
#include "rpcutils.h"

#define MAXCBS 1024
enum {UNUSED = 0, USED = 1};

static pthread_mutex_t cb_mutex = PTHREAD_MUTEX_INITIALIZER;
typedef struct cb_entry cb_entry;

struct cb_entry {
	int used;
	callback_args cb;
	struct sockaddr_in addr;
};
static cb_entry cb_table[MAXCBS];
static int cb_count = 0;
static int cb_index = 0;

static int find_cbid_of_host(struct sockaddr_in *raddr)
{
	int i, j;

	i = 0;
	j = 0;
	while (i < cb_count && j < MAXCBS) {
		if (cb_table[j].used == USED) {
			/* Matching only the host addresses */
			if (cb_table[j].addr.sin_addr.s_addr == raddr->sin_addr.s_addr) {
				return j;
			}
			i++;
		}
		j++;
	}
	return -1;
}

static int find_unused_cbid(void)
{
	int i;

	i = 0;
	while (i < MAXCBS) {
		if (cb_table[i].used != USED) {
			return i;
		}
		i++;
	}
	return -1;
}

static int register_callback(callback_args *cb, struct sockaddr_in *raddr)
{
	//int cbid;

	pthread_mutex_lock(&cb_mutex);
#if 0
	if ((cbid = find_cbid_of_host(raddr)) < 0) {
		cbid = find_unused_cbid();
	}
	if (cbid >= 0) {
		cb_table[cbid].cb.prog = cb->prog;
		cb_table[cbid].cb.vers = cb->vers;
		cb_table[cbid].cb.proto = cb->proto;
		memcpy(&cb_table[cbid].addr, raddr, sizeof(struct sockaddr_in));
	}
#else
	cb_table[cb_index].cb.prog = cb->prog;
	cb_table[cb_index].cb.vers = cb->vers;
	cb_table[cb_index].cb.proto = cb->proto;
	cb_index++;
#endif
	pthread_mutex_unlock(&cb_mutex);
	return cb_index - 1;
	//return cbid;
}

bool_t
register_cb_1_svc(callback_args arg1, int *result,  struct svc_req *rqstp)
{
	bool_t retval = 1;
	struct sockaddr_in *remote_address;
	int cbid;

	/*
	 * insert server code here
	 */

	remote_address = svc_getcaller(rqstp->rq_xprt);
	*result = register_callback(&arg1, remote_address);
	printf("Returned callback id = %d\n", *result);
	return retval;
	return retval;
}

struct entry {
	fname name;
	int   status;
	int   ncbs;
	int   cbs[MAXCBS];
};

static struct entry table[1024];
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

static int check_index(fname name, int *unused)
{
	int i;

	*unused = -1;
	for (i = 0; i < 1024; i++) {
		if (table[i].status != UNUSED) {
			printf("index %d comparing %s %s\n", i, table[i].name, name);
			if (!strcmp(table[i].name, name)) {
				return i;
			}
		}
		else {
			if (*unused == -1 || i < *unused) {
				*unused = i;
			}
		}
	}
	return -1;
}

static int insert(fname name, int cb)
{
	int index, unused, ret;

	pthread_mutex_lock(&mutex);
	index = check_index(name, &unused);
	if (index < 0) {
		table[unused].status = USED;
		table[unused].name = strdup(name);
		ret = unused;
	}
	else {
		ret = index;
	}
	if (cb >= 0 && table[ret].cbs[cb] == 0) {
		table[ret].cbs[cb] = 1;
		if (table[ret].ncbs <= cb) {
			table[ret].ncbs = cb + 1;
		}
	}
	pthread_mutex_unlock(&mutex);
	return ret;
}

struct recipe {
	int count;
	unsigned char **hashes;
	size_t  *hash_lengths;
};

void destroy_recipe(struct recipe *recipe)
{
	int i;
	free(recipe->hash_lengths);
	for (i = 0; i < recipe->count; i++) {
		free(recipe->hashes[i]);
	}
	free(recipe->hashes);
	free(recipe);
	return;
}

struct recipe* get_recipe_list(char *filename, int chunk_size, int *error)
{
	struct stat statbuf;
	struct recipe *recipe = NULL;
	int i, fd;
	void *file_addr;
	size_t size = 0;

	if (stat(filename, &statbuf) < 0) {
		*error = errno;
		return NULL;
	}
	if (S_ISDIR(statbuf.st_mode)) {
		*error = EISDIR;
		return NULL;
	}
	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		*error = errno;
		return NULL;
	}
	if ((file_addr = mmap(NULL, statbuf.st_size, PROT_READ, MAP_SHARED, fd, 0)) == MAP_FAILED) {
		close(fd);
		*error = errno;
		return NULL;
	}
	recipe = (struct recipe *) calloc(1, sizeof(struct recipe));
	if (recipe == NULL) {
		munmap(file_addr, statbuf.st_size);
		close(fd);
		*error = ENOMEM;
		return NULL;
	}
	recipe->count = statbuf.st_size / chunk_size + 1;
	recipe->hashes = (unsigned char **) calloc(recipe->count, sizeof(unsigned char *));
	if (recipe->hashes == NULL) {
		free(recipe);
		munmap(file_addr, statbuf.st_size);
		close(fd);
		*error = ENOMEM;
		return NULL;
	}
	recipe->hash_lengths = (size_t *) calloc (recipe->count, sizeof(size_t));
	if (recipe->hash_lengths == NULL) {
		free(recipe->hashes);
		free(recipe);
		munmap(file_addr, statbuf.st_size);
		close(fd);
		*error = ENOMEM;
		return NULL;
	}
	*error = 0;
	for (i = 0; i < recipe->count; i++) {
		int ret;
		size_t input_length = 0;

		if (size + chunk_size <= statbuf.st_size) {
			input_length = chunk_size;
		}
		else {
			input_length = statbuf.st_size - size;
		}
		if ((ret = sha1((char *)file_addr + i * chunk_size, input_length,
						&recipe->hashes[i], &recipe->hash_lengths[i])) < 0) {
			*error = -ret;
			break;
		}
		size += input_length;
	}
	if (*error < 0) {
		destroy_recipe(recipe);
		munmap(file_addr, statbuf.st_size);
		close(fd);
		return NULL;
	}
	munmap(file_addr, statbuf.st_size);
	close(fd);
	return recipe;
}

static void print(unsigned char *hash, int hash_length)
{
	int i;

	for (i = 0; i < hash_length; i++) {
		printf("%02x", hash[i]);
	}
	printf("\n");
	return;
}

bool_t
get_hashes_1_svc(hash_args arg1, hash_resp *result,  struct svc_req *rqstp)
{
	bool_t retval = 1;
	int ret, error, i;
	struct recipe *list = NULL;

	/*
	 * insert server code here
	 */
	list = get_recipe_list(arg1.name, 4096, &error);
	if (list == NULL) {
		result->hash_resp_len = 0;
		result->hash_resp_val = NULL;
		return retval;
	}
	insert(arg1.name, arg1.cbid);

	printf("File %s\n", arg1.name);
	result->hash_resp_len = list->count;
	result->hash_resp_val = (hash_res *) calloc(result->hash_resp_len * sizeof(hash_res), 1);
	for (i = 0; i < result->hash_resp_len; i++) {
		char *ptr;

		ptr = result->hash_resp_val[i].digest = (hash) calloc(HASHLENGTH + 1, 1);
		memcpy(ptr, list->hashes[i], HASHLENGTH);
		print(list->hashes[i], HASHLENGTH);
	}
	destroy_recipe(list);

	return retval;
}

static int callback_sharers(int index, fname name, hash_resp arg2)
{
	int i;

	for (i = 0; i < table[index].ncbs; i++) {
		CLIENT *clnt;
		enum clnt_stat ans;
		struct timeval tv;

		if (table[index].cbs[i] == 1) {
			int prog, vers, proto;
			struct sockaddr our_addr;

			printf("callback for mount id = %d\n", i);
			prog = cb_table[i].cb.prog;
			vers = cb_table[i].cb.vers;
			proto = cb_table[i].cb.proto;

			clnt = get_svc_handle("192.168.2.97", prog, vers, proto, 21, &our_addr);
			if (clnt == NULL) {
				clnt_pcreateerror("Could not contact sharer");
			}
			else {
				put_hashes_1_argument arg;
				int res;
				struct timeval tv;

				arg.name = name;
				arg.arg2 = arg2;
				tv.tv_sec = 21;
				ans = clnt_call(clnt, UPDATE, (xdrproc_t) xdr_put_hashes_1_argument, (caddr_t)&arg,
						(xdrproc_t) xdr_int, (caddr_t) &res, tv);
				if (ans != RPC_SUCCESS) {
					clnt_perror(clnt, "clnt update call failed");
				}
				else {
					printf("Mount id %d was updated successfully\n", i);
				}
				clnt_destroy(clnt);
			}
		}
	}
	return;
}


bool_t
put_hashes_1_svc(fname name, hash_resp arg2, int *result,  struct svc_req *rqstp)
{
	bool_t retval = 1;
	int index, unused;

	/*
	 * insert server code here
	 */
	index = insert(name, -1);
	/* now we need to callback */
	*result = callback_sharers(index, name, arg2);

	return retval;
}

int
locksvc_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
